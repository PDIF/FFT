#ifndef DIGITALSIGNALPROCESS_H
#define DIGITALSIGNALPROCESS_H

//#include <cmath>
#include <complex>
#include <vector>
#include <algorithm>
//#include <map>

#include <assert.h>

#include <iostream>
#include "ReferenceSineWave.h"
#include "RingBuffer.h"

class DigitalSignalProcess
{
    using base_wave_t    = const ReferenceSineWave;
    using size_vec_t     = std::vector<size_t>;
    using complex_t      = std::complex<double>;
    using complex_vec_t  = std::vector<complex_t>;
    using ring_complex_t = RingBuffer<complex_t>;
    using ring_base_t    = std::vector<ring_complex_t>;



public:

    DigitalSignalProcess(
        const base_wave_t&  initReferenceSineWave,
        const size_vec_t&   initHarmonics   = defaultHarmonicsData(),
        double              initCorrection  = defaultCorrectionDegree());


    void update(double newValue);

    const complex_vec_t& value() const;

    const complex_t& value(size_t harmonic) const;

    virtual ~DigitalSignalProcess();


private:

    base_wave_t&    _baseSineWave;      //ссылка на эталонную синусоиду

    size_vec_t      _harmonics;         //вектор искомых гармоник

    ring_base_t     _base;              //вектор кольцевых буферов для хранения
                                        //мгновенных значений, умноженных на шаг
    ring_base_t     _convolution;       //матрицасвертка векторов

    complex_vec_t   _current;

    complex_vec_t   _value;

    const complex_t _defaultComplex;
    
    complex_t       _angleCorrection;

    //=================================
    size_vec_t      _initNodes();

    complex_vec_t   _initComplexVector(size_t newSize);

    ring_base_t     _initConvolution(size_t newSize);

    ring_base_t     _initBase();


    void            _updateCurrent(const complex_t& newValue);

    void            _updateBase(complex_t newValue);

    void            _updateResult();

    void            _updateConvolution();



    size_t _computeIndexCorrection(double correctionDegree);



    static constexpr double defaultCorrectionDegree() {
        return 0.0;
    };

    static constexpr complex_t zeroComplex() {
        return complex_t(0.0, 0.0);
    };


    static const size_vec_t defaultHarmonicsData() {
        return size_vec_t{0, 1, 2, 3, 5, 6, 7, 9, 11, 12, 13};
    };



//    static const long   defaultHarmonic() {return 1L           ;};
//    static const double defaultAngle()    {return 0.0          ;};


    //static const double


};



#endif // DIGITALSIGNALPROCESS_H
